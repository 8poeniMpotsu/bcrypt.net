# bcrypt.net - next

Porting of bcrypt.codeplex.com with enhanced security, missing fixes, features and better .net support.

# Nuget  

[![NuGet](https://img.shields.io/nuget/v/BCrypt.Net-Next.svg?style=flat-square)](https://www.nuget.org/packages/BCrypt.Net-Next)

Download using nuget or Paket (https://fsprojects.github.io/Paket/)

Package: https://www.nuget.org/packages/BCrypt.Net-Next/

## Compiling

You'll need at least VS2017 with the current SDK https://www.microsoft.com/net/download;

The nuget packages can be built by running `buildfornuget.cmd`
or 

```
dotnet restore .\src
dotnet pack .\src\BCrypt.Net --configuration Release
```

## Tests

You can run the tests from the main folder by typing `dotnet test .\src\BCrypt.Net.UnitTests\`
Running `TestGenerateSaltWithMaxWorkFactor` will take significant time.

## Description

A .Net port of jBCrypt implemented in C#. It uses a variant of the Blowfish encryption algorithm’s keying schedule, and introduces a work factor, which allows you to determine how expensive the hash function will be, allowing the algorithm to be "future-proof".

## Details
This is, for all intents and purposes, a direct port of jBCrypt written by Damien Miller.  The main differences are the addition of some convenience methods and some mild re-factoring.  The easiest way to verify BCrypt.Net's parity with jBCrypt is to compare the unit tests.

For an overview of why BCrypt is important see How to Safely Store a Password.  In general it's a hashing algorithm that can be adjusted over time to require more CPU power to generate the hashes.  This, in essence, provides some protection against Moore's Law.  That is, as computers get faster, this algorithm can be adjusted to require more CPU power.  The more CPU power that's required to hash a given password, the more time a "hacker" must invest, per password.  Since the "work factor" is embedded in the resultant hash, the hashes generated by this algorithm are forward/backward-compatible.

## Why BCrypt

### From How to Safely Store a Password:

It uses a variant of the Blowfish encryption algorithm’s keying schedule, and introduces a work factor, which allows you to determine how expensive the hash function will be. Because of this, BCrypt can keep up with Moore’s law. As computers get faster you can increase the work factor and the hash will get slower.

### Blowfish-based scheme - Versioning/BCrypt Revisions

> Niels Provos and David Mazières designed a crypt() scheme called bcrypt based on Blowfish, and presented it at USENIX in 1999.[14]

The printable form of these hashes starts with $2$, $2a$, $2b$, $2x$ or $2y$ depending on which variant of the algorithm is used:

```
$2$ – Currently obsolete
$2a$ – The current key used to identify this scheme. 
       Since a major security flaw was discovered in 2011 in a third-party implementation of the algorithm, 
       hashes indicated by this string are now ambiguous and might have been generated by the flawed 
       implementation, or a subsequent fixed, implementation. 
       The flaw may be triggered by some password strings containing non-ASCII characters, such as specially 
       crafted password strings.
$2b$ – Used by some recent implementations which include a mitigation to a wraparound problem. 
       Previous versions of the algorithm have a problem with long passwords. By design, long passwords 
       are truncated at 72 characters, but there is an 8-bit wraparound problem with certain password 
       lengths resulting in weak hashes.
$2x$ – Post-2011 bug discovery, old hashes can be renamed to be $2x$ to indicate that they were generated with 
       the broken algorithm. These hashes are still weak, but at least it's clear which algorithm was used to 
       generate them.
$2y$ – Post Post-2011 bug discovery, $2y$ may be used to unambiguously use the new, corrected algorithm. On an 
       implementation suffering from the bug, $2y$ simply won't work. On a newer, fixed implementation, it will 
       produce the same result as using $2a$.
```

First and foremost this library originated as a port of jBCrypt from `mindrot`, ans subsequently the bcrypt revision
was set to match, which in this case is `$2a$`.
This has been changed as handling only the single revision causes issues cross-platform with implementations that moved
altered their revision to handle migrations and other issues.

```
The original bcrypt code (released in OpenBSD 2.1) identified itself as
$2$. Shortly after release, a bug was fixed and the hash identifier
changed to $2a$. Support for "minor" versions wasn't really
planned, but it was backwards compatible.

Solar Designer wrote a second implementation of bcrypt. This
reimplementation suffered from a flaw dealing with 8 bit characters,
and led to the introduction of the 'x' and 'y' flavors. OpenBSD did
not have this problem and supports neither 'x' nor 'y' hash versions.

---

Solar found a bug in their OpenBSD implementation of bcrypt when hashing
long passwords. The length is stored in an unsigned char type, which
will overflow and wrap at 256. Although we consider the existence of
affected hashes very rare, in order to differentiate hashes generated
before and after the fix, we are introducing a new minor 'b'.

OpenBSD 5.5 (coming this spring) will accept and verify 'b' hashes,
although it will still generate 'a' hashes. OpenBSD 5.6 (coming this
fall) will change to generating 'b' hashes by default.

A future release of Solar's bcrypt code should also support 'b'.
```

**There is no difference between 2a, 2x, 2y, and 2b. They all output the same result.**

* https://github.com/spring-projects/spring-security/issues/3320
* https://en.wikipedia.org/wiki/Crypt_(C)#Blowfish-based_scheme
* http://undeadly.org/cgi?action=article&sid=20140224132743
* http://marc.info/?l=openbsd-misc&m=139320023202696

# Releases

https://github.com/BcryptNet/bcrypt.net/releases

*v2.0.1 -*

* Corrects usage of Secure random number generator
* Change UTF8 handling to safer default (throwOnInvalidBytes: true)
 * .NET Encoding.UTF8 encoding instance does not raise exceptions used to encode bytes which cannot represent a valid encoding & will return the same 'unknown' character instead. This can cause entropy loss when converting from bytes to strings.
* Change secure equals to match .net identity implementation
* Inline vars in encipher method

*v2.0.0 -*

Fresh release packaged for the majority of .net & containing safe-equals to reduce the risks from timing attacks https://en.wikipedia.org/wiki/Timing_attack / https://cryptocoding.net/index.php/Coding_rules#Compare_secret_strings_in_constant_time
Technically the implementation details of BCrypt theoretically mitigate against a timing attacks. But the Bcrypt.net official validation function was vulerable to timing attacks as it returned as soon as a non-matching byte was found in the hash comparison.

